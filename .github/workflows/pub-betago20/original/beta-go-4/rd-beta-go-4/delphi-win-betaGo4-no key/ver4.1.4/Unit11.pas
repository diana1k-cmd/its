unit Unit11;

interface

uses
  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
  Dialogs;
Const
{$I CLIENT.PAS}

{ COMMAND CODES }
   KLCHECK       = 1;   // check for key-lok II
   GETSN         = 3;   // get serial number for keyLok II

{ KEYBD Function Arguments }
   STARTANTIDEBUGGER = 0;   { Launch ppmon.exe anti-debugger }




type
  TForm11 = class(TForm)
  private
    { Private declarations }
  public
    { Public declarations }
  end;


procedure CheckForKEYLOK1Click;
procedure Exit1Click;
function silentDongleCheck:boolean;


{DLL Selection:
    Standalone Workstation - Activate function declarations referencing KL2DLL32.DLL
    Accessing device over network using Netbios protocol - Activate function declarations referencing NWKL2_32.DLL}
function KFUNC(Arg1, Arg2, Arg3, Arg4: DWord): longint stdcall; external 'KL2DLL32.DLL' name '_KFUNC@16';
{NOTICE: Do NOT try to run from Delphi IDE if KEYBD calls are enabled.  You should disable KEYBD calls until your
  program is fully debugged, then activate the code, and retest the executable generated by Delphi from outside of
  the IDE.  Otherwise, your program will terminate each time you call the security system, because the IDE has a
  debugger attached to your program.  The KEYBD call activates the anti-debugging utility to protect your program
  from being debugged.}
function KEYBD(Arg1: DWord): Word stdcall; external 'KL2DLL32.DLL' name '_KEYBD@4';
{function KFUNC(Arg1, Arg2, Arg3, Arg4: DWord): longint stdcall; external 'NWKL2_32.DLL' name '_KFUNC@16';
function KEYBD(Arg1: DWord): Word stdcall; external 'NWKL2_32.DLL' name '_KEYBD@4';}

var
  ReturnValue1, ReturnValue2, RotatedValue, RotatedValue1: Word;
  Form11: TForm11;
implementation

{$R *.dfm}
{==========================================================================}
{===================== MISCELLANEOUS SUBROUTINES ==========================}
{==========================================================================}


{** KTASK **}
{This is a generic routine used for all calls to the security device.
 ReturnValue1 and ReturnValue2 should be returned to the calling routine for
 subsequent processing and/or comparison actions.}

Procedure KTASK(CommandCode, Argument2, Argument3, Argument4: word);
    var
       KBReturnValue: word;
       RV2, ReturnValue: longint;

    Begin
       {KBReturnValue := KEYBD(STARTANTIDEBUGGER);}
       ReturnValue := KFUNC(CommandCode, Argument2, Argument3, Argument4);
       ReturnValue1 := ReturnValue and 65535;
       ReturnValue2 := ReturnValue shr 16;
    End;
{** KTASK **}

{** RotateLeft **}
Procedure RotateLeft(Target, ShiftCount: word);
   var
      LocalTarget: dword;
      HighBit, i: word;

   Begin
      i := 0;
      LocalTarget := Target;
      while i < ShiftCount do
      Begin
         HighBit := LocalTarget and $8000;
         LocalTarget := ((LocalTarget shl 1) and $FFFF) + (HighBit shr 15);
         i := i+1;
      End;
      RotatedValue := LocalTarget and $FFFF;
   End;
{** RotateLeft **}

procedure CheckForKEYLOK1Click;
var
  sn:string;
begin
   KTASK(KLCHECK, ValidateCode1, ValidateCode2, ValidateCode3);
   RotateLeft(ReturnValue1, ReturnValue2 and 7);
   RotatedValue1 := RotatedValue;
   RotateLeft(ReturnValue2, ReturnValue1 and 15);
   KTASK( RotatedValue1 xor ReadCode3 xor ReturnValue2, RotatedValue, ReturnValue1 xor ReturnValue2, 0);

   {NOTE: Higher security can be achieved by using return values in computations
          and performing comparison of computed values to expected values deeper
          in your code than here}

   {NOTE: Higher security can be achieved by using return values in computations
          and performing comparison of computed values to expected values deeper
          in your code than here}

   if (ReturnValue1 = ClientIDCode1) and (ReturnValue2 = ClientIDCode2) then
      Begin
         MessageDlg('The proper KEY device is attached.', mtInformation, mbOKCancel, 0);

         KTASK(3, ValidateCode1, ValidateCode2, ValidateCode3);
         str(ValidateCode1,sn);
         MessageDlg('The Serial Number is '+sn,mtInformation,mbOKCancel,0);
         //RotateLeft(ReturnValue1, ReturnValue2 and 7);
         //RotatedValue1 := RotatedValue;
         //RotateLeft(ReturnValue2, ReturnValue1 and 15);
         //KTASK( RotatedValue1 xor ReadCode3 xor ReturnValue2, RotatedValue, ReturnValue1 xor ReturnValue2, 0);
      End
   else
      Begin
         //MessageDlg('No KEY or the wrong device is attached. Halting Program',
          //           mtError,mbOKCancel,0);
         //halt(0);

      End;

end;


function silentDongleCheck:boolean;
var
  sn:string;
  found:boolean;
begin
   KTASK(KLCHECK, ValidateCode1, ValidateCode2, ValidateCode3);
   RotateLeft(ReturnValue1, ReturnValue2 and 7);
   RotatedValue1 := RotatedValue;
   RotateLeft(ReturnValue2, ReturnValue1 and 15);
   KTASK( RotatedValue1 xor ReadCode3 xor ReturnValue2, RotatedValue, ReturnValue1 xor ReturnValue2, 0);

   {NOTE: Higher security can be achieved by using return values in computations
          and performing comparison of computed values to expected values deeper
          in your code than here}

   {NOTE: Higher security can be achieved by using return values in computations
          and performing comparison of computed values to expected values deeper
          in your code than here}

   if (ReturnValue1 = ClientIDCode1) and (ReturnValue2 = ClientIDCode2) then
      Begin
         //MessageDlg('The proper KEY-LOK device is attached.', mtInformation, mbOKCancel, 0);
         found:=true;
         KTASK(3, ValidateCode1, ValidateCode2, ValidateCode3);
         str(ValidateCode1,sn);
         //MessageDlg('The Serial Number is '+sn,mtInformation,mbOKCancel,0);
      End
   else
      Begin
         //MessageDlg('No KEY or the wrong device is attached.',mtError,mbOKCancel,0);
         found:=true;
      End;
silentDongleCheck:=found;
end;

procedure Exit1Click;
begin
     Halt(0);
end;

end.
